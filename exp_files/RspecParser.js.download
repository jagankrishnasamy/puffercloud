/*
 * rspecParser.js
 *
 * Parse Requests, Manifests, and Advertisements
 *
 */

(function () {
  var loader = window.jacksmod.loader;
//  loader.loadScript('common/RspecLib.js');
})();

(function () {
  'use strict';
  var $j = window.jacksmod;
  var rs = $j.common.RspecLib;

  var START = 0;
  var AFTER_TRIM = 1;
  var AFTER_PARSE = 2;
  var AFTER_ROOT = 3;
  var FOUND_NODES = 4;
  var FOUND_LANS = 5;
  var AFTER_ENDPOINTS = 6;
  var FOUND_HOSTS = 7;
  var MAP_HOSTS = 8;
  var END = 9;
  
  function RspecParser()
  {
    this.phase = END;
    this.failed = false;
    this.result = null;
    this.rspec = '';
    this.root = null;
  };

  var p = RspecParser.prototype;

  p.replaceRspec = function (rspec)
  {
    this.rspec = rspec;
    this.failed = false;
    this.result = {
      nodes: {},
      lans: {},
      interfaces: {},
      interfaceList: [],
      sites: {},
      hosts: {}
    };
    this.nodeCount = 0;
    this.nodeList = [];
    this.nodeNameToId = {};
    this.defaultSite = {
      urn: undefined,
      name: undefined,
      custom: {},
      id: _.uniqueId()
    };
    this.phase = START;
    this.parsed = null;
    this.query = $([]);
    this.index = 0;
    this.root = null;
  };

  p.isParsed = function ()
  {
    return this.phase === END;
  };

  p.isFailed = function ()
  {
    return this.failed;
  };

  p.getGraph = function ()
  {
    if (this.phase === END)
    {
      return this.result;
    }
    else
    {
      return null;
    }
  };

  p.parseStep = function ()
  {
    try
    {
      if (this.phase === START)
      {
	this.trim();
	this.phase = AFTER_TRIM;
      }
      else if (this.phase === AFTER_TRIM)
      {
	this.parse();
	this.phase = AFTER_PARSE;
      }
      else if (this.phase === AFTER_PARSE)
      {
	this.makeRoot();
	this.phase = AFTER_ROOT;
      }
      else if (this.phase === AFTER_ROOT)
      {
	this.findNodes();
	this.phase = FOUND_NODES;
      }
      else if (this.phase === FOUND_NODES)
      {
	if (this.index >= this.query.length)
	{
	  this.findLans();
	  this.phase = FOUND_LANS;
	}
	else
	{
	  this.process(_.bind(this.parseNode, this));
	}
      }
      else if (this.phase === FOUND_LANS)
      {
	if (this.index >= this.query.length)
	{
	  this.buildEndpoints();
	  this.phase = AFTER_ENDPOINTS;
	}
	else
	{
	  this.process(_.bind(this.parseLan, this));
	}
      }
      else if (this.phase === AFTER_ENDPOINTS)
      {
	this.findHosts();
	this.phase = FOUND_HOSTS;
      }
      else if (this.phase === FOUND_HOSTS)
      {
	if (this.index >= this.query.length)
	{
	  this.phase = MAP_HOSTS;
	  this.query = _.keys(this.result.hosts);
	  this.index = 0;
	}
	else
	{
	  this.process(_.bind(this.parseHost, this));
	}
      }
      else if (this.phase === MAP_HOSTS)
      {
	if (this.index >= this.query.length)
	{
	  this.phase = END;
	}
	else
	{
	  this.process(_.bind(this.mapHost, this));
	}
      }
    }
    catch (e)
    {
      console.log(e)
      this.failed = true;
      this.phase = END;
      this.result = null;
    }
  };

  p.trim = function ()
  {
    var findEncoding = RegExp('^\\s*<\\?[^?]*\\?>');
    var match = findEncoding.exec(this.rspec);
    if (match)
    {
      this.rspec = this.rspec.slice(match[0].length);
    }
  };

  p.parse = function ()
  {
    this.parsed = $.parseXML(this.rspec);
  };

  p.makeRoot = function ()
  {
    this.root = $(this.parsed.documentElement);
  };

  p.findNodes = function ()
  {
    this.query = rs.findSameNS(this.root, 'node');
    this.index = 0;
  };

  p.findLans = function ()
  {
    this.query = rs.findSameNS(this.root, 'link');
    this.index = 0;
  };

  p.findHosts = function ()
  {
    this.query = $(this.root[0].getElementsByTagNameNS(rs.emulabNamespace, 'vhost'));
    this.index = 0;
  };

  p.process = function (f)
  {
    var count = 0;
    while (count < 20 && this.index < this.query.length)
    {
      f($(this.query[this.index]));
      count += 1;
      this.index += 1;
    }
  };

  p.buildEndpoints = function ()
  {
    _.each(this.result.lans, function (lan) {
      _.each(lan.nodeIndices, function (nodeIndex) {
	lan.endpoints.push(this.nodeList[nodeIndex]);
      }.bind(this));
    }.bind(this));
    if (this.nodeCount === 0)
    {
      this.result.sites[this.defaultSite.id] = this.defaultSite;
    }
  };

  p.mapHost = function (hostid)
  {
    var host = this.result.hosts[hostid];
    _.each(host.nodes, function (name) {
      var id = this.nodeNameToId(id);
      if (id)
      {
	var node = this.result.nodes[id];
	node.parentHost = host.id;
	if (node.group)
	{
	  host.group = node.group;
	}
      }
    }.bind(this));
  };

  p.parseNode = function (xml)
  {
    var node = {
      custom: {},
      warnings: {},
      execute: [],
      group: this.defaultSite.id,
      hardware: rs.findChildAttribute(xml, 'hardware_type', 'name'),
      hostport: undefined,
      icon: undefined,
      id: _.uniqueId(),
      image: undefined,
      imageVersion: rs.findChildAttribute(xml, 'disk_image', 'version'),
      index: this.nodeCount,
      install: [],
      interfaces: [],
      logins: undefined,
      name: xml.attr('client_id'),
      routable: false,
      routable_ip: undefined,
      sliverId: xml.attr('sliver_id'),
      sshurl: undefined,
      type: rs.findChildAttribute(xml, 'sliver_type', 'name'),
      xml: xml,
      dataset_id: undefined,
      dataset_mount: undefined,
      dataset_mount_option: 'remote',
      parentHost: undefined
    };

    this.nodeNameToId[node.name] = node.id;

    node.image = rs.findChildAttribute(xml, 'disk_image', 'name');
    if (! node.image)
    {
      node.image = rs.findChildAttribute(xml, 'disk_image', 'url');
    }

    var iconParent = $(xml[0].getElementsByTagNameNS(rs.jacksNamespace, 'icon'));
    if (iconParent.length > 0)
    {
      node.icon = iconParent.attr('url');
    }

    var nomacParent = $(xml[0].getElementsByTagNameNS(rs.jacksNamespace, 'nomac'));
    if (nomacParent.length > 0)
    {
      node.nomac = true;
    }

    var taggingParent = $(xml[0].getElementsByTagNameNS(rs.emulabNamespace, 'vlan_tagging'));
    if (taggingParent.length > 0)
    {
      node.nontrivial = (taggingParent.attr('enabled') === 'true');
    }

    var bindsiteParent = $(xml[0].getElementsByTagNameNS(rs.jacksNamespace, 'bindsite'));
    if (bindsiteParent.length > 0)
    {
      node.bindsite = bindsiteParent.attr('name');
    }
/*
    var foundIcon = _.findWhere(context.canvasOptions.icons,
				{ id: node.icon });
    if (node.icon && ! foundIcon)
    {
      node.custom.icon = true;
    }

    var foundImage = _.findWhere(context.canvasOptions.images,
				 { id: node.image });
    if (node.image && ! foundImage)
    {
      node.custom.image = true;
    }

    var foundHardware = _.findWhere(context.canvasOptions.hardware,
				    { id: node.hardware });
    if (node.hardware && ! foundHardware)
    {
      node.custom.hardware = true;
    }

    var foundType = _.findWhere(context.canvasOptions.types,
				{ id: node.type });
    if (node.type && ! foundType)
    {
      node.custom.type = true;
    }
*/
    if (node.type && node.type === 'emulab-blockstore')
    {
      var blockstore = $(xml[0].getElementsByTagNameNS(rs.emulabNamespace, 'blockstore'));
      if (blockstore.length > 0)
      {
	this.dataset_mount = blockstore.attr('mountpoint');
	this.dataset_option = 'remote';
	if (blockstore.attr('rwclone') === 'true')
	{
	  this.dataset_option = 'rwclone';
	}
	else if (blockstore.attr('readonly') === 'true')
	{
	  this.dataset_option = 'readonly';
	}
	this.dataset_id = blockstore.attr('dataset');
      }
    }
    
    var services = rs.findSameNS(xml, 'services');
    services.each(function () {
      var executeItems = rs.findSameNS($(this), 'execute');
      executeItems.each(function () {
	node.execute.push({
	  'rspec': $(this),
	  'command': $(this).attr('command'),
	  'shell': $(this).attr('shell')
	});
      });
      var installItems = rs.findSameNS($(this), 'install');
      installItems.each(function () {
	node.install.push({
	  'rspec': $(this),
	  'url': $(this).attr('url'),
	  'install_path': $(this).attr('install_path')
	});
      });
    });

    var routableItems = xml[0].getElementsByTagNameNS(rs.emulabNamespace, 'routable_control_ip');
    if (routableItems.length > 0)
    {
      node.routable = true;
      var hostItems = rs.findSameNS(xml, 'host');
      if (hostItems.length > 0)
      {
	node.routable_ip = $(hostItems[0]).attr('ipv4');
      }
    }
    var cmUrn = xml.attr('component_manager_id');
    var siteElement = $(xml[0].getElementsByTagNameNS(rs.jacksNamespace, 'site'));
    var siteName = null;
    if (siteElement.length > 0)
    {
      siteName = siteElement.attr('id');
    }
    if (cmUrn || siteName)
    {
      node.group = this.findOrMakeSite(cmUrn, siteName).id;
    }
    else if (! this.result.sites[this.defaultSite.id])
    {
      // This is already part of the default site. Make sure the
      // default site is in the sites list.
      this.result.sites[this.defaultSite.id] = this.defaultSite;
    }
    var that = this;
    rs.findSameNS(xml, 'interface').each(function() {
      var iface = {
	name: $(this).attr('client_id'),
	nodeName: node.name,
	node_index: that.nodeCount,
	id: _.uniqueId(),
	node: node,
	nodeId: node.id,
	mac: $(this).attr('mac_address'),
	bandwidth: undefined,
      };
      var ip = $(this.getElementsByTagNameNS(rs.rspecNamespace, 'ip'));
      if (ip.length > 0)
      {
	iface.ip = ip.attr('address');
	iface.ipType = ip.attr('type');
	iface.netmask = ip.attr('netmask');
      }
      node.interfaces.push(iface.id);
      that.result.interfaces[iface.id] = iface;
      that.result.interfaceList.push(iface);
    });

    if (services.length > 0)
    {
      var login  = rs.findSameNS(services, 'login');
      login.each(function () {
	var user   = $(this).attr('username');
	var host   = $(this).attr('hostname');
	var port   = $(this).attr('port');

	if (host !== undefined && port !== undefined)
	{
	  node.hostport  = host + ':' + port;
	  if (user !== undefined)
	  {
	    node.sshurl = 'ssh://' + user + '@' + host + ':' + port + '/';
	  }
	}
	if (user !== undefined &&
	    host !== undefined &&
	    port !== undefined)
	{
	  var newLogin = user + '@' + host + ':' + port;
	  if (node.logins)
	  {
	    node.logins += ', ' + newLogin;
	  }
	  else
	  {
	    node.logins = newLogin;
	  }
	}
      });
    }

    this.nodeHost(xml, node);

    //mergeNode(node, result.nodes);
    this.nodeList.push(node);
    this.result.nodes[node.id] = node;
    this.nodeCount += 1;
  };

  p.parseLan = function (xml)
  {
    var link = {
      custom: {},
      warnings: {},
      //index: count,
      interfaces: [],
      linkType: rs.findChildAttribute(xml, 'link_type', 'name'),
      name: xml.attr('client_id'),
      openflow: undefined,
      nodeIndices: [],
      endpoints: [],
      endpointNames: [],
      id: _.uniqueId(),
      sliverId: xml.attr('sliver_id'),
      sharedvlan: undefined,
      transitSites: {},
      xml: xml,
      interswitch: true
    };
    /*
    var foundType = _.findWhere(context.canvasOptions.linkTypes,
				{ id: link.linkType });
    if (link.linkType && ! foundType)
    {
      link.custom.linkType = true;
    }
    */

    var shared = $(xml[0].getElementsByTagNameNS(rs.vlanNamespace,
						 'link_shared_vlan'));
    if (shared.length > 0)
    {
      link.sharedvlan = shared.attr('name');
    }

    var interswitch = $(xml[0].getElementsByTagNameNS(rs.emulabNamespace,
						      'interswitch'));
    if (interswitch.length > 0)
    {
      link.interswitch = (interswitch.attr('allow') === 'yes');
    }
/*
    var foundShared = _.findWhere(context.canvasOptions.sharedvlans,
				  { id: link.sharedvlan });
    if (link.sharedvlan && ! foundShared)
    {
      link.custom.sharedvlan = true;
    }
*/
    /*
    var openflow = parseOpenflow(xml);
    if (openflow)
    {
      link.openflow = openflow;
    }
*/
    var repeatIface = false;
    var ifacerefs = rs.findSameNS(xml, 'interface_ref');
    _.each(ifacerefs, function (ref) {
      var targetName = $(ref).attr('client_id');
      /*
       * First we have map the client_ids to the node by
       * searching all of the interfaces we put into the
       * list above.
       *
       */
      _.each(this.result.interfaceList, function (iface) {
      	if (iface.name == targetName)
	{
	  /*
	  if (used_iface[iface.name])
	  {
	    repeatIface = true;
	  }
	  else
	  {
	    used_iface[iface.name] = 1;
	  }
	  */
	  link.nodeIndices.push(iface.node_index);
	  link.endpointNames.push(iface.nodeName);
	  link.interfaces.push(iface.id);
	  iface.linkId = link.id;
	}
      }.bind(this));
    }.bind(this));

    var that = this;
    var sites = $(xml[0].getElementsByTagNameNS(rs.rspecNamespace,
						'component_manager'));
    sites.each(function () {
      var name = $(this).attr('name');
      var found = false;
      _.each(link.nodeIndices, function (nodeId) {
	var node = that.nodeList[nodeId];
	var currentSite = that.result.sites[node.group];
	if (currentSite.urn && currentSite.urn === name)
	{
	  found = true;
	}
      });
      if (! found)
      {
	link.transitSites[name] = 1;
      }
    });

    var properties = $(xml[0].getElementsByTagNameNS(rs.rspecNamespace,
						     'property'));
    properties.each(function () {
      var sourceName = $(this).attr('source_id');
      var bw = $(this).attr('capacity');
      if (bw !== null && bw !== undefined && bw !== '')
      {
	_.each(that.result.interfaceList, function (iface) {
      	  if (iface.name == sourceName)
	  {
	    iface.bandwidth = bw;
	  }
	});
      }
    });
    this.result.lans[link.id] = link;
/*
    if (! repeatIface)
    {
      this.result.links[link.id] = link;
    }
    return repeatIface;
*/
  };

  p.parseHost = function (xml)
  {
    var newHost = {
      id: _.uniqueId(),
      name: xml.attr('client_id'),
      attachedNode: undefined,
      nodes: [],
      group: undefined
    };
    var vmlist = rs.findSameNS(xml, 'vm');
    vmlist.each(function () {
      newHost.nodes.push($(this).attr('client_id'));
    });
    this.result.hosts[newHost.id] = newHost;
  };

  p.nodeHost = function (xml, node)
  {
    var vmlist = $(xml[0].getElementsByTagNameNS(rs.emulabNamespace, 'vmlist'));
    if (vmlist.length > 0)
    {
      vmlist = rs.findSameNS(vmlist, 'vm');
      var newHost = {
	id: _.uniqueId(),
	name: xml.attr('client_id'),
	attachedNode: xml.attr('client_id'),
	nodes: [],
	group: undefined
      };
      node.isHost = xml.attr('client_id');
      vmlist.each(function () {
	newHost.nodes.push($(this).attr('client_id'));
      });
      this.result.hosts[newHost.id] = newHost;
    }
  };

  p.findOrMakeSite = function (cmUrn, name)
  {
    var result;
    var siteList;
    // First try to match by Component Manager URN
    if (cmUrn)
    {
      siteList = _.where(_.values(this.result.sites), { urn: cmUrn });
      if (siteList.length > 0)
      {
	result = siteList[0];
	if (! result.name)
	{
	  result.name = name;
	}
      }
    }
    // If that doesn't work, try to match by Jacks site ID
    if (! result && name)
    {
      siteList = _.where(_.values(this.result.sites), { name: name });
      if (siteList.length > 0)
      {
	result = siteList[0];
	if (! result.urn)
	{
	  result.urn = cmUrn;
	}
      }
    }
    // If all else fails, just create a new one
    if (! result)
    {
      result = {
	custom: {},
	urn: cmUrn,
	id: _.uniqueId()
      };
      if (name)
      {
	result.name = name;
      }
/*
      var foundUrn = _.findWhere(context.canvasOptions.aggregates,
				 { id: result.urn });
      if (result.urn && ! foundUrn)
      {
	result.custom.urn = true;
      }
*/
      this.result.sites[result.id] = result;
    }
    return result;
  };

  $j.common.RspecParser = RspecParser;
})();
