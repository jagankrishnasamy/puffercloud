(function () {
  var loader = window.jacksmod.loader;
  /*
    loader.loadScript('common/ForceGraph.js');
*/
})();

(function () {
  'use strict';
  var common = window.jacksmod.common;

  var GraphComponent = common.ComponentQuery.extend({

    initialize: function () {
      this.force = new common.ForceGraph();
      this.forceSite = new common.ForceGraph();
      this.forceHost = new common.ForceGraph();
      this.nodes = {};
      this.lans = {};
      this.sites = {};
      this.hosts = {};

      this.endpoints = undefined;
      this.nodeToSite = {};
      this.nodeToHost = {};
      this.hostToSite = {};
    },
    
    render: function () {
      if (! this.rendered)
      {
	this.$el = $(`
<div>
  <!--
  <button class="fullscreen-button btn btn-default"><span class="glyphicon glyphicon-resize-full"></span>
  <button class="switch-to-map-button btn btn-default">Map</button>
  -->
  <svg xmlns="http://www.w3.org/2000/svg"
    xmlns:svg="http://www.w3.org/2000/svg" version="1.1"
    viewBox="-100 -100 1200 1200" 
    style="width:100%; height:100%; background-color: white; position:absolute; top:0; left:0; z-index:-1;">
  </svg>
</div>
`);
	this.root = d3v4.select(this.$('svg')[0]);
	this.hullBase = this.root.append('svg:g');
	this.hostBase = this.root.append('svg:g');
	this.lanBase = this.root.append('svg:g');

      	this.nodeBase = this.root.append('svg:g');
	this.hullLabelBase = this.root.append('svg:g');
	this.hostLabelBase = this.root.append('svg:g');
	this.oldNodeCount = 0;
	this.oldLanCount = 0;
	this.$('.switch-to-map-button').on('click', function (event) {
	  event.preventDefault();
	  this.trigger('switch-to-map');
	  return false;
	}.bind(this));
	this.$('.fullscreen-button').on('click', function (event) {
	  event.preventDefault();
	  if (document.fullscreenElement ||
	      document.webkitFullscreenElement)
	  {
	    $('.switch-to-map-button').show();
	    $('.fullscreen-button').html('<span class="glyphicon glyphicon-resize-full"></span>');
	    if (document.webkitExitFullscreen)
	    {
	      document.webkitExitFullscreen();
	    }
	  }
	  else
	  {
	    $('.switch-to-map-button').hide();
	    $('.fullscreen-button').html('<span class="glyphicon glyphicon-resize-small"></span>');
	    if (this.$el[0].webkitRequestFullscreen)
	    {
	      this.$el[0].webkitRequestFullscreen();
	    }
	  }
	}.bind(this));
//	this.gmapShown = false;
      }
      return this.superRender();
    },

    update: function (state) {
      if (state)
      {
	if (state.panelWidth !== undefined)
	{
	  this.force.panelWidth = state.panelWidth;
	}
	if (state.panelHeight !== undefined)
	{
	  this.force.panelHeight = state.panelHeight;
	}
	this.force.updateScale();
	if (state.graph)
	{
	  this.updateSites(state.graph.sites);
	  this.updateHosts(state.graph.hosts);
	  this.updateNodes(state.graph.nodes);
	  this.updateLans(state.graph.lans);
	  var nodeCount = _.keys(state.graph.nodes).length;
	  var lanCount = _.keys(state.graph.lans).length;
	  if (nodeCount !== this.oldNodeCount ||
	      lanCount !== this.oldLanCount)
	  {
	    //this.updateForceSite();
	    this.force.skipAhead();
	    this.oldNodeCount = nodeCount;
	    this.oldLanCount = lanCount;
	  }
	  /*
	  if (! this.gmapShown)
	  {
	    this.$('#gmap').show();
	    var mapPos = {
	      center: { lat: 40.7647337, lng: -111.863586 },
	      zoom: 12
	    }
	    this.gmap = new google.maps.Map(this.$('#gmap')[0],
					    mapPos);
	    this.gmapShown = true;
	  }
	  */
	}
	if (state.shown && this.endpoints)
	{
	  this.updateForce();
	}
      }
      this.superUpdate(state);
    },

    updateNodes: function (graphNodes) {
      this.cleanupOld(this.nodes, graphNodes, 'node');
      this.updateItems(this.nodes, graphNodes, this.nodeBase,
		       common.component.GraphNodeComponent, 'node', {});
      /*
      this._each(_.values(graphNodes), function (node) {
	if (this.nodes[node.id] === undefined)
	{
	  var newNode = new common.component.GraphNodeComponent();
	  newNode.render(this.nodeBase);
	  this.children['node' + node.id] = newNode;
	  this.nodes[node.id] = newNode;
	}
	this.nodes[node.id].update({ node: node, force: this.force, scale: this.scale });
      });
*/
    },

    updateLans: function (graphLans) {
      this.cleanupOld(this.lans, graphLans, 'lan');
      var endpoints = {};
      this._each(_.keys(graphLans), function (key) {
	endpoints[key] = [];
	this._each(graphLans[key].endpoints, function (end) {
	  endpoints[key].push(this.nodes[end.id].forceNode);
	});
      });
      this.endpoints = endpoints;
      this.updateItems(this.lans, graphLans, this.lanBase,
		       common.component.GraphLanComponent, 'lan',
		       endpoints);
    },

    updateSites: function (graphSites) {
      /*
      this.cleanupOld(this.sites, graphSites, 'site');
      this.updateItems(this.sites, graphSites, this.hullBase,
		       common.component.GraphSiteComponent, 'site',
		       {
			 forceSite: this.forceSite,
			 forceHost: this.forceHost,
			 hullLabel: this.hullLabel
		       });
*/
    },

    updateHosts: function (graphHosts) {
      /*
      this.cleanupOld(this.hosts, graphHosts, 'host');
      this.updateItems(this.hosts, graphHosts, this.hostBase,
		       common.component.GraphHostComponent, 'host',
		       {
			 forceHost: this.forceHost,
			 hostLabel: this.hostLabel
		       });
*/
    },

    cleanupOld: function (result, standard, type)
    {
      var currentKeys = _.keys(result);
      this._each(currentKeys, function (key) {
	if (standard[key] === undefined) {
	  delete this.children[type + result[key].id];
	  result[key].cleanupForce(this.force);
	  result[key].cleanup();
	  delete result[key];
	}
      });
    },

    updateItems: function (items, models, base, C, type, data) {
      this._each(_.values(models), function (model) {
	if (items[model.id] === undefined)
	{
	  var newItem = new C();
	  newItem.render(base);
	  this.children[type + model.id] = newItem;
	  items[model.id] = newItem;
	}
	var arg = { force: this.force };
	arg[type] = model;
	if (type == 'node')
	{
	  if (model.parentHost)
	  {
	    arg.hostNode = this.hosts[model.parentHost].hostNode;
	  }
	  if (model.group)
	  {
	    //arg.siteNode = this.sites[model.group].siteNode;
	  }
	}
	else if (type === 'lan')
	{
	  arg.endpoints = data[model.id];
	}
	else if (type === 'site')
	{
	  arg.data = data;
	}
	else if (type === 'host')
	{
	  arg.data = data;
	  if (model.group)
	  {
	    //arg.siteNode = this.sites[model.group].siteNode;
	  }
	}
	items[model.id].update(arg);
      });      
    },
      
    updateForce: function () {
      this.force.updateScale();
      this._each(_.values(this.nodes), function (node) {
	node.updateForce(this.force);
      });
      this._each(_.keys(this.lans), function (key) {
	this.lans[key].updateForce(this.force, this.endpoints[key]);
      });
    },

    updateForceSite: function () {
      this.forceSite.skipAhead();
      this._each(_.values(this.sites), function (site) {
	site.updateForce(this.force);
      });
      this.forceHost.skipAhead();
      this._each(_.values(this.hosts), function (host) {
	host.updateForce(this.force);
      });
    }
    
  });
  
  common.component.GraphComponent = GraphComponent;
})();
